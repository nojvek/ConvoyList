/// <reference path="./css.d.ts"/>
"use strict";
/**
 * @module Maintains a single stylesheet and keeps it in sync with requested styles
 */
var FreeStyle = require("free-style");
/** Raf for node + browser */
var raf = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame;
/**
 * Only calls cb all sync operations settle
 */
var afterAllSync = (new (function () {
    function class_1() {
        var _this = this;
        this.pending = 0;
        this.afterAllSync = function (cb) {
            _this.pending++;
            var pending = _this.pending;
            raf(function () {
                if (pending !== _this.pending)
                    return;
                cb();
            });
        };
    }
    return class_1;
}())).afterAllSync;
/**
 * Before we send styles to freeStyle we should convert any CSSType<T> to string
 * Call this whenever something might be a CSSType.
 */
function ensureString(x) {
    return typeof x.type === 'string'
        ? x.toString()
        : x;
}
exports.ensureString = ensureString;
/**
 * We have a single stylesheet that we update as components register themselves
 */
var freeStyle = FreeStyle.create();
var lastFreeStyleChangeId = freeStyle.changeId;
var singletonTag = typeof window === 'undefined' ? { innerHTML: '' } : document.createElement('style');
if (typeof document !== 'undefined')
    document.head.appendChild(singletonTag);
/** Checks if the style tag needs updating and if so queues up the change */
var styleUpdated = function () {
    if (freeStyle.changeId === lastFreeStyleChangeId
        && !pendingRawChange)
        return;
    lastFreeStyleChangeId = freeStyle.changeId;
    pendingRawChange = false;
    afterAllSync(flush);
};
var pendingRawChange = false;
var raw = '';
/**
 * Insert `raw` CSS as a string. This is useful for e.g.
 * - third party CSS that you are customizing with template strings
 * - generating raw CSS in JavaScript
 * - reset libraries like normalize.css that you can use without loaders
 */
function cssRaw(mustBeValidCSS) {
    if (!mustBeValidCSS)
        return;
    raw = raw + mustBeValidCSS;
    pendingRawChange = true;
    styleUpdated();
}
exports.cssRaw = cssRaw;
/**
 * Flushes styles to the singleton tag
 **/
function flush() {
    singletonTag.innerHTML = exports.css();
}
/**
 * Helps with testing. Reinitializes FreeStyle + raw
 */
function reinit() {
    /** reinit freestyle */
    freeStyle = FreeStyle.create();
    lastFreeStyleChangeId = freeStyle.changeId;
    /** reinit raw */
    raw = '';
    pendingRawChange = false;
    /** Clear any styles that were flushed */
    singletonTag.innerHTML = '';
}
exports.reinit = reinit;
/**
 * Allows use to use the stylesheet in a node.js environment
 */
exports.css = function () { return raw ? raw + freeStyle.getStyles() : freeStyle.getStyles(); };
/**
 * Takes CSSProperties and return a generated className you can use on your component
 */
function style() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i - 0] = arguments[_i];
    }
    var object = extend.apply(void 0, objects);
    var className = freeStyle.registerStyle(object);
    styleUpdated();
    return className;
}
exports.style = style;
/**
 * Takes CSSProperties and registers it to a global selector (body, html, etc.)
 */
function cssRule(selector) {
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var object = extend.apply(void 0, objects);
    freeStyle.registerRule(selector, object);
    styleUpdated();
    return;
}
exports.cssRule = cssRule;
/**
 * Takes Keyframes and returns a generated animation name
 */
function keyframes(frames) {
    // resolve keyframe css property helpers
    for (var key in frames) {
        var frame = frames[key];
        for (var prop in frame) {
            frame[prop] = ensureString(frame[prop]);
        }
    }
    var animationName = freeStyle.registerKeyframes(frames);
    styleUpdated();
    return animationName;
}
exports.keyframes = keyframes;
/**
 * Helper for you to create a CSSFunction
 * Assumption is that most css function fall into this pattern:
 * `function-name(param [, param])`
 */
function cssFunction(functionName) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
    }
    var parts = params.map(ensureString).join(',');
    return functionName + "(" + parts + ")";
}
exports.cssFunction = cssFunction;
/**
 * Merges various styles into a single style object.
 * Note: if two objects have the same property the last one wins
 */
function extend() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i - 0] = arguments[_i];
    }
    /** The final result we will return */
    var result = {};
    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
        var object = objects_1[_a];
        for (var key in object) {
            var val = object[key];
            if (
            // Some psuedo state or media query
            (key.indexOf('&') !== -1 || key.indexOf('@media') === 0)
                && result[key]) {
                // Then extend in the final result
                result[key] = extend(result[key], object);
            }
            else {
                result[key] = ensureString(val);
            }
        }
    }
    return result;
}
exports.extend = extend;
/**
 * Utility to join classes conditionally
 */
function classes() {
    var classes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        classes[_i - 0] = arguments[_i];
    }
    return classes.filter(function (c) { return !!c; }).join(' ');
}
exports.classes = classes;
